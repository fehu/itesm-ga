<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>src/Parcial2/Labyrinth.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
\documentclass{article}

%include polycode.fmt


\usepackage[utf8]{inputenc}
\usepackage[spanish, mexico]{babel}
\usepackage{amsmath, hyperref, xcolor, tikz, mdframed}
\usepackage[shortlabels, inline]{enumitem}

% \usepackage{showframe}

\newenvironment{note}
    {\begin{mdframed}[leftmargin=1cm,
                 skipabove=1em,
                 skipbelow=1em,
                 rightline=false,
                 topline=false,
                 bottomline=false,
                 linewidth=2pt]
        \textbf{Nota}\\}
    {\end{mdframed}}


\newcommand{\crule}[2][1pt] {\begin{center}\rule{#2\textwidth}{#1}\end{center}}

\def\github{http://fehu.github.io/itesm-ga/}

\newcommand{\hssrc} [2]{\href{\github/api/src/#1.html}{src/#2}}
\newcommand{\hstest}[2]{\href{\github/api/tests/src/#1.html}{test/#2}}


\begin{document}

\begin{code}
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE UndecidableInstances, FlexibleInstances #-}</span>
<a name="line-2"></a>
<a name="line-3"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Parcial2</span><span class='hs-varop'>.</span><span class='hs-conid'>Labyrinth</span> <span class='hs-keyword'>where</span>
<a name="line-4"></a>
<a name="line-5"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Exception</span>
<a name="line-6"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Arrow</span> <span class='hs-layout'>(</span><span class='hs-varid'>first</span><span class='hs-layout'>,</span> <span class='hs-varid'>second</span><span class='hs-layout'>)</span>
<a name="line-7"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>Fix</span>
<a name="line-8"></a>
<a name="line-9"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Tuple</span> <span class='hs-layout'>(</span><span class='hs-varid'>swap</span><span class='hs-layout'>)</span>
<a name="line-10"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>isJust</span><span class='hs-layout'>,</span> <span class='hs-varid'>fromJust</span><span class='hs-layout'>)</span>
<a name="line-11"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set</span><span class='hs-layout'>,</span> <span class='hs-varid'>member</span><span class='hs-layout'>)</span>
<a name="line-12"></a>  <span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Set</span>
<a name="line-13"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Real</span> <span class='hs-layout'>(</span><span class='hs-varid'>infinity</span><span class='hs-layout'>)</span>
<a name="line-14"></a>
<a name="line-15"></a>
<a name="line-16"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>Parcial2</span><span class='hs-varop'>.</span><span class='hs-conid'>ReadLabyrinth</span>
<a name="line-17"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>GeneticAlgorithm</span>
<a name="line-18"></a>
<a name="line-19"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>System</span><span class='hs-varop'>.</span><span class='hs-conid'>Random</span>
</pre>\end{code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introducción}


El mapa (laberinto), descrito en la tarea, se define como un grafo:
nodos --- un conjunto de puntos (con posiciones correspondientes);
aristas --- la existencia de rutas directas.

\begin{code}
<pre><a name="line-20"></a>  <span class='hs-keyword'>data</span> <span class='hs-conid'>Labyrinth</span> <span class='hs-varid'>point</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Labyrinth</span> <span class='hs-layout'>{</span>
<a name="line-21"></a>        <span class='hs-varid'>nodes</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Set</span> <span class='hs-varid'>point</span><span class='hs-layout'>,</span>
<a name="line-22"></a>        <span class='hs-varid'>edges</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Set</span> <span class='hs-layout'>(</span><span class='hs-varid'>point</span><span class='hs-layout'>,</span> <span class='hs-varid'>point</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-23"></a>        <span class='hs-varid'>initial</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>point</span><span class='hs-layout'>,</span>
<a name="line-24"></a>        <span class='hs-varid'>target</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varid'>point</span>
<a name="line-25"></a>      <span class='hs-layout'>}</span>
<a name="line-26"></a>
<a name="line-27"></a>  <span class='hs-varid'>edgeOf</span> <span class='hs-varid'>p</span> <span class='hs-varid'>es</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varop'>`member`</span> <span class='hs-varid'>es</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>p</span><span class='hs-layout'>,</span> <span class='hs-varid'>swap</span> <span class='hs-varid'>p</span><span class='hs-keyglyph'>]</span>
<a name="line-28"></a>
<a name="line-29"></a>  <span class='hs-varid'>mapPoints</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Labyrinth</span> <span class='hs-varid'>ns</span> <span class='hs-varid'>es</span> <span class='hs-varid'>i</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Labyrinth</span> <span class='hs-layout'>{</span>
<a name="line-30"></a>        <span class='hs-varid'>nodes</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set</span><span class='hs-varop'>.</span><span class='hs-varid'>map</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ns</span><span class='hs-layout'>,</span>
<a name="line-31"></a>        <span class='hs-varid'>edges</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set</span><span class='hs-varop'>.</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>first</span> <span class='hs-varid'>f</span> <span class='hs-varop'>.</span> <span class='hs-varid'>second</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varid'>es</span><span class='hs-layout'>,</span>
<a name="line-32"></a>        <span class='hs-varid'>initial</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>i</span><span class='hs-layout'>,</span>
<a name="line-33"></a>        <span class='hs-varid'>target</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>t</span>
<a name="line-34"></a>    <span class='hs-layout'>}</span>
<a name="line-35"></a>
</pre>\end{code}


Se define la \emph{distancia directa} entre los nodos que están conectados por una arista.

\begin{code}
<pre><a name="line-36"></a>  <span class='hs-keyword'>data</span> <span class='hs-conid'>DirectDistance</span> <span class='hs-varid'>point</span> <span class='hs-varid'>dist</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DirectDistance</span> <span class='hs-layout'>{</span>
<a name="line-37"></a>       <span class='hs-varid'>labyrinthDist</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Labyrinth</span> <span class='hs-varid'>point</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>point</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>point</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-varid'>dist</span>
<a name="line-38"></a>      <span class='hs-layout'>}</span>
<a name="line-39"></a>
<a name="line-40"></a>  <span class='hs-varid'>mkDirectDistance</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DirectDistance</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>l</span> <span class='hs-varid'>v1</span> <span class='hs-varid'>v2</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-41"></a>    <span class='hs-keyword'>if</span> <span class='hs-layout'>(</span><span class='hs-varid'>v1</span><span class='hs-layout'>,</span><span class='hs-varid'>v2</span><span class='hs-layout'>)</span> <span class='hs-varop'>`edgeOf`</span> <span class='hs-varid'>edges</span> <span class='hs-varid'>l</span> <span class='hs-keyword'>then</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>v1</span> <span class='hs-varid'>v2</span><span class='hs-layout'>)</span> <span class='hs-keyword'>else</span> <span class='hs-conid'>Nothing</span>
</pre>\end{code}




\bigskip
\noindent
El algoritmo genético abstracto está definido en \hssrc{GeneticAlgorithm}{GeneticAlgorithm.hs}.
Su implementación se presentará a continuación.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementación}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Lectura de mapas}

Se utiliza un mapa 2D:

<pre><a name="line-42"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>newtype</span> <span class='hs-conid'>Point2D</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Point2D</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Ord</span><span class='hs-layout'>)</span>
<a name="line-43"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Show</span> <span class='hs-conid'>Point2D</span> <span class='hs-keyword'>where</span>
<a name="line-44"></a><span class='hs-varop'>&gt;</span>   <span class='hs-varid'>show</span> <span class='hs-layout'>(</span><span class='hs-conid'>Point2D</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>show</span> <span class='hs-varid'>x</span> <span class='hs-varop'>++</span> <span class='hs-str'>"-"</span> <span class='hs-varop'>++</span> <span class='hs-varid'>show</span> <span class='hs-varid'>y</span>
</pre>
<pre><a name="line-45"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>Labyrinth2D</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Labyrinth</span> <span class='hs-conid'>Point2D</span>
</pre>

La lectura del archivo del mapa se encuentra en
\hssrc{Parcial2-ReadLabyrinth}{Parcial2/ReadLabyrinth.hs}.
Aquí se presenta la construcción del grafo a partir del mapa leido.


\begin{code}
<pre><a name="line-46"></a>  <span class='hs-varid'>readLabyrinth2D</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FilePath</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>String</span><span class='hs-keyglyph'>]</span> <span class='hs-conid'>Labyrinth2D</span><span class='hs-layout'>)</span>
<a name="line-47"></a>
<a name="line-48"></a>  <span class='hs-varid'>readLabyrinth2D</span> <span class='hs-varid'>file</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>build</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>try</span> <span class='hs-layout'>(</span><span class='hs-varid'>readFile</span> <span class='hs-varid'>file</span><span class='hs-layout'>)</span>
<a name="line-49"></a>    <span class='hs-keyword'>where</span>
<a name="line-50"></a>        <span class='hs-varid'>build</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-varid'>err</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Left</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>displayException</span> <span class='hs-layout'>(</span><span class='hs-varid'>err</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SomeException</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-51"></a>        <span class='hs-varid'>build</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>parseLabyrinth</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>of</span>
<a name="line-52"></a>                                   <span class='hs-conid'>Left</span> <span class='hs-varid'>errS</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Left</span> <span class='hs-varid'>errS</span>
<a name="line-53"></a>                                   <span class='hs-conid'>Right</span> <span class='hs-varid'>l</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-varid'>build'</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>
<a name="line-54"></a>
<a name="line-55"></a>        <span class='hs-varid'>build'</span> <span class='hs-layout'>(</span><span class='hs-conid'>LabyrinthDescription</span> <span class='hs-varid'>n</span> <span class='hs-varid'>conn</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-layout'>,</span><span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varid'>coords</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-56"></a>          <span class='hs-keyword'>let</span> <span class='hs-varid'>get</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Point2D</span> <span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>coords</span> <span class='hs-varop'>!!</span><span class='hs-layout'>)</span>
<a name="line-57"></a>          <span class='hs-keyword'>in</span> <span class='hs-conid'>Labyrinth</span>
<a name="line-58"></a>                       <span class='hs-layout'>(</span><span class='hs-conid'>Set</span><span class='hs-varop'>.</span><span class='hs-varid'>fromList</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-conid'>Point2D</span> <span class='hs-varid'>coords</span><span class='hs-layout'>)</span>
<a name="line-59"></a>                       <span class='hs-layout'>(</span><span class='hs-conid'>Set</span><span class='hs-varop'>.</span><span class='hs-varid'>fromList</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>first</span> <span class='hs-varid'>get</span> <span class='hs-varop'>.</span> <span class='hs-varid'>second</span> <span class='hs-varid'>get</span><span class='hs-layout'>)</span> <span class='hs-varid'>coords</span><span class='hs-layout'>)</span>
<a name="line-60"></a>                       <span class='hs-layout'>(</span><span class='hs-varid'>get</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span>
<a name="line-61"></a>                       <span class='hs-layout'>(</span><span class='hs-varid'>get</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-62"></a>
</pre>\end{code}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Adoptación}


El valor de \emph{aptitud de adoptación} se llamará \emph{ruta} y se define
para permitir destinguir facilmente los dos tipos de rutas
(encodificadas en los cromosomas) posibles:

\begin{itemize}
  \item \textbf{Ruta completa}: es una ruta valida
    ($\exists$ una conección entre cada par de genes adjuntos) que contiene
    en punto inicial y el punto meta.

    Se caracteriza por la \emph{longitud de la ruta}.

    El resultado, esperado del algoritmo genético es la más corta de estas rutas.

  \item \textbf{Ruta parcial}: es una ruta que
    \begin{enumerate*}[1)]
        \item contiene pares de genes adjuntos, los cuales no están conectados, o
        \item no contiene los ambos puntos: inicio y meta.
    \end{enumerate*}

    Se caracteriza por los tres valores:
    \begin{enumerate}

        \item \emph{valides} $= \dfrac
            {\text{número de aristas existentes}}
            {\text{número de aristas total}}$.

            \textit{aristas existentes ---
                    aristas que existen entre los pares de genes adjuntos.}

        \item los \emph{puntos de interés} que contiene la ruta.
        \item la longitud sumatoria de las sub-rutas en el cromosoma.

    \end{enumerate}

\end{itemize}



\begin{code}
<pre><a name="line-63"></a>
<a name="line-64"></a>  <span class='hs-keyword'>data</span> <span class='hs-conid'>POI</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>POIInit</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>POITarget</span> <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Ord</span><span class='hs-layout'>,</span> <span class='hs-conid'>Enum</span><span class='hs-layout'>,</span> <span class='hs-conid'>Show</span><span class='hs-layout'>)</span>
<a name="line-65"></a>  <span class='hs-keyword'>data</span> <span class='hs-conid'>POIs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>POINone</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>POISome</span> <span class='hs-conid'>POI</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>POIBoth</span> <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Show</span><span class='hs-layout'>)</span>
<a name="line-66"></a>
<a name="line-67"></a>  <span class='hs-keyword'>instance</span> <span class='hs-conid'>Ord</span> <span class='hs-conid'>POIs</span> <span class='hs-keyword'>where</span>
<a name="line-68"></a>    <span class='hs-varid'>x</span> <span class='hs-varop'>`compare`</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>val</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`compare`</span> <span class='hs-varid'>val</span> <span class='hs-varid'>y</span> <span class='hs-keyword'>where</span>
<a name="line-69"></a>        <span class='hs-varid'>val</span> <span class='hs-conid'>POINone</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-70"></a>        <span class='hs-varid'>val</span> <span class='hs-layout'>(</span><span class='hs-conid'>POISome</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-71"></a>        <span class='hs-varid'>val</span> <span class='hs-conid'>POIBoth</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>2</span>
<a name="line-72"></a>
<a name="line-73"></a>
<a name="line-74"></a>  <span class='hs-keyword'>data</span> <span class='hs-conid'>Route</span> <span class='hs-keyglyph'>=</span>
<a name="line-75"></a>      <span class='hs-conid'>CompleteRoute</span> <span class='hs-layout'>{</span> <span class='hs-varid'>routeLength</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Double</span> <span class='hs-layout'>}</span>
<a name="line-76"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PartialRoute</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>partialValidess</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Double</span>
<a name="line-77"></a>                    <span class='hs-layout'>,</span> <span class='hs-varid'>partialPOI</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>POIs</span>
<a name="line-78"></a>                    <span class='hs-layout'>,</span> <span class='hs-varid'>partialLength</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Double</span>
<a name="line-79"></a>                    <span class='hs-layout'>}</span>
<a name="line-80"></a>    <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Show</span><span class='hs-layout'>)</span>
</pre>\end{code}

\noindent Para la busqueda de la ruta mas corta,
se define el orden sobre las rutas de tal manera, que
una lista de \emph{rutas}, ordenada ascendentamente,
tendrá los mejores elementos en el principio.
\begin{enumerate}

  \item Cualquiera \emph{ruta completa} \underline{es minor} que cualquiera \emph{ruta parcial}.
        $$\forall x \in \textit{ruta completa},
                  y \in \textit{ruta parcial}     \implies x < y$$

  \item Dos \emph{rutas completas} se comparan por su \underline{longitud} sin cambios de la orden.
        \begin{align*}
            \begin{tabular}{l}
                \forall x \in \textit{ruta completa}, x \sim r_1\\
                \forall y \in \textit{ruta completa}, y \sim r_2
            \end{tabular}
            & \implies
            & \begin{cases}
                x < y & \mbox{si } r_1 < r_2 \\
                x > y & \mbox{si } r_1 > r_2 \\
                x = y & \mbox{en otro caso}
              \end{cases}
        \end{align*}

  \item Dos \emph{rutas parciales} se comparan por sus \underline{tres componentes} en orden
        \underline{lexicográfico}, que quiere decir que
        primero se comparan los primeros elementes, si son igual, se comparan los segundos, etc.,
        hasta que la comparación da un resultado diferente de igualidad o se termina la lista.

        El orden de la comparación se cambia al opuesto.

        \begin{align*}
            \begin{tabular}{l}
                \forall x \in \textit{ruta parcial}, x \sim \langle v_x, i_x, l_x \rangle \\
                \forall y \in \textit{ruta parcial}, y \sim \langle v_y, i_y, l_y \rangle
            \end{tabular}
            & \implies
            & \begin{cases}
                x < y & \mbox{si } \langle v_x, i_x, l_x \rangle > \langle v_y, i_y, l_y \rangle \\
                x > y & \mbox{si } \langle v_x, i_x, l_x \rangle < \langle v_y, i_y, l_y \rangle \\
                x = y & \mbox{en otro caso}
              \end{cases}
        \end{align*}

\end{enumerate}

\begin{code}
<pre><a name="line-81"></a>  <span class='hs-keyword'>instance</span> <span class='hs-conid'>Ord</span> <span class='hs-conid'>Route</span> <span class='hs-keyword'>where</span>
<a name="line-82"></a>    <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>CompleteRoute</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>       <span class='hs-layout'>(</span><span class='hs-conid'>CompleteRoute</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compare</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span>
<a name="line-83"></a>    <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>PartialRoute</span> <span class='hs-varid'>v1</span> <span class='hs-varid'>i1</span> <span class='hs-varid'>l1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>PartialRoute</span> <span class='hs-varid'>v2</span> <span class='hs-varid'>i2</span> <span class='hs-varid'>l2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-varid'>v2</span><span class='hs-layout'>,</span><span class='hs-varid'>i2</span><span class='hs-layout'>,</span><span class='hs-varid'>l2</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>v1</span><span class='hs-layout'>,</span><span class='hs-varid'>i1</span><span class='hs-layout'>,</span><span class='hs-varid'>l1</span><span class='hs-layout'>)</span>
<a name="line-84"></a>    <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>CompleteRoute</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>        <span class='hs-conid'>PartialRoute</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LT</span>
<a name="line-85"></a>    <span class='hs-varid'>compare</span>  <span class='hs-conid'>PartialRoute</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>         <span class='hs-layout'>(</span><span class='hs-conid'>CompleteRoute</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GT</span>
</pre>\end{code}


Las pruebas del contenedor \emph{Route} se encuentran en \hstest{Parcial2-Route}{Parcial2/Route.hs}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Algoritmo genético}


<pre><a name="line-86"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>GA</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GA</span> <span class='hs-conid'>Labyrinth2D</span>
</pre>
Se usa adelante un alias de tuple \verb|(a,a)| para denotar el número de hijos de \emph{crossover}.

\begin{code}
<pre><a name="line-87"></a>  <span class='hs-keyword'>newtype</span> <span class='hs-conid'>Pair</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Pair</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-88"></a>  <span class='hs-varid'>unwrapPair</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>p</span>
<a name="line-89"></a>  <span class='hs-varid'>pair2List</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span><span class='hs-layout'>,</span><span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span><span class='hs-layout'>,</span><span class='hs-varid'>s</span><span class='hs-keyglyph'>]</span>
</pre>\end{code}



\noindent
Se define la metrica sobre los puntos del grafo:
$$
  \mathrm{dist}(p_1, p_2) = \begin{cases}
       \mathit{Just}~ d_E(p_1, p_2)
    &  \mbox{si } \exists \text{ arista, connectando } p_1 \text{ y } p_2
    \\ \mathit{Nothing}
    &  \mbox{en otro caso}
  \end{cases}
\text {, donde}

d_E \text{ --- es la distancia euclidiana entre dos puntos.}
$$


<pre><a name="line-90"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>eDist'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkDirectDistance</span> <span class='hs-varop'>$</span>
<a name="line-91"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>Point2D</span> <span class='hs-layout'>(</span><span class='hs-varid'>x1</span><span class='hs-layout'>,</span><span class='hs-varid'>x2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Point2D</span> <span class='hs-layout'>(</span><span class='hs-varid'>y1</span><span class='hs-layout'>,</span><span class='hs-varid'>y2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-92"></a><span class='hs-varop'>&gt;</span>               <span class='hs-varid'>sqrt</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fromIntegral</span> <span class='hs-varop'>$</span>
<a name="line-93"></a><span class='hs-varop'>&gt;</span>               <span class='hs-varid'>abs</span><span class='hs-layout'>(</span><span class='hs-varid'>x1</span><span class='hs-comment'>-</span><span class='hs-varid'>x2</span><span class='hs-layout'>)</span><span class='hs-varop'>^</span><span class='hs-num'>2</span> <span class='hs-varop'>+</span> <span class='hs-varid'>abs</span><span class='hs-layout'>(</span><span class='hs-varid'>y1</span><span class='hs-comment'>-</span><span class='hs-varid'>y2</span><span class='hs-layout'>)</span><span class='hs-varop'>^</span><span class='hs-num'>2</span>
<a name="line-94"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>eDist</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>labyrinthDist</span> <span class='hs-varid'>eDist'</span>
</pre>


\crule{1}
\medskip
\noindent
Se define la instancia de la clase \emph{GeneticAlgorithm} para \emph{GA}
empezando con los tipos y siguiendo con los métodos.

<pre><a name="line-95"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>GeneticAlgorithm</span> <span class='hs-conid'>GA</span> <span class='hs-keyword'>where</span>
</pre>
\begin{enumerate}[(1)]

\item Un \emph{gen} se define como \underline{nodo del laberinto}
      y un \emph{cromosoma} como una \underline{lista de genes}.

<pre><a name="line-96"></a><span class='hs-varop'>&gt;</span>    <span class='hs-keyword'>type</span> <span class='hs-conid'>Gene</span> <span class='hs-conid'>GA</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Point2D</span>
<a name="line-97"></a><span class='hs-varop'>&gt;</span>    <span class='hs-keyword'>type</span> <span class='hs-conid'>Chromosome</span> <span class='hs-conid'>GA</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Point2D</span><span class='hs-keyglyph'>]</span>
<a name="line-98"></a><span class='hs-varop'>&gt;</span>    <span class='hs-comment'>-- listGenes :: Chromosome ga \rightarrow$ [Gene ga]</span>
<a name="line-99"></a><span class='hs-varop'>&gt;</span>    <span class='hs-varid'>listGenes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id</span>
</pre>
\item Los valores de aptitud ya fueron descritos previamente.

<pre><a name="line-100"></a><span class='hs-varop'>&gt;</span>    <span class='hs-keyword'>type</span> <span class='hs-conid'>Fitness</span> <span class='hs-conid'>GA</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Route</span>
</pre>

\item Para denotar que la operación de \emph{crossover} preserva el tamaño de población,
su resultado se marca como un par de hijos.

<pre><a name="line-101"></a><span class='hs-varop'>&gt;</span>    <span class='hs-keyword'>type</span> <span class='hs-conid'>CrossoverChildren</span> <span class='hs-conid'>GA</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Pair</span>
</pre>
\item La información de entrada para generación de la población --- el laberinto.

<pre><a name="line-102"></a><span class='hs-varop'>&gt;</span>    <span class='hs-keyword'>type</span> <span class='hs-conid'>InputData</span> <span class='hs-conid'>GA</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Labyrinth2D</span>
</pre>
\item El resultado es el \underline{mejor cromosoma} obtenido.

<pre><a name="line-103"></a><span class='hs-varop'>&gt;</span>    <span class='hs-keyword'>type</span> <span class='hs-conid'>ResultData</span> <span class='hs-conid'>GA</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Chromosome</span> <span class='hs-conid'>GA</span>
</pre>


\item La \textbf{aptitud de adoptación} se define como:

$$
f(c) &= \begin{cases}
  \mathit{Length} ~ \mathrm{length}
    & \mbox{si } \begin{tabular}{l}
             \forall i = \overline{[1,\mathrm{len}-1]} \Rightarrow \\
             \qquad \exists \text{ arista, connectando } c_{i-1} \text{ y } c_i \\
             \land ~\mathrm{initial} \in \{c\}\\
             \land ~\mathrm{target} \in \{c\}
      \end{tabular}
  \\
  \mathit{Validess} ~\mathrm{validess}
    & \mbox{en otro caso}
  \end{cases}
$$

\qquad\qquad  donde
\begin{align*}
\mathrm{length} &= \sum\limits_{i = 1}^{\mathrm{len}-1} \mathrm{dist}(c_{i-1}, c_i)
\\
\mathrm{validess} &= \text{grado de valides (se describe antes)}
\end{align*}

\begin{code}
<pre><a name="line-104"></a>    <span class='hs-comment'>-- fitness :: ga \rightarrow$ Chromosome ga \rightarrow$ Fitness ga</span>
<a name="line-105"></a>     <span class='hs-varid'>fitness</span> <span class='hs-layout'>(</span><span class='hs-conid'>GA</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>genes</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span>
<a name="line-106"></a>                            <span class='hs-varid'>lPairs</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span><span class='hs-conop'>:</span><span class='hs-varid'>s</span><span class='hs-conop'>:</span><span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span><span class='hs-layout'>,</span><span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>lPairs</span> <span class='hs-layout'>(</span><span class='hs-varid'>s</span><span class='hs-conop'>:</span><span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-107"></a>                            <span class='hs-varid'>lPairs</span> <span class='hs-keyword'>_</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-108"></a>                            <span class='hs-varid'>dists</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>uncurry</span> <span class='hs-varop'>$</span> <span class='hs-varid'>eDist</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>lPairs</span> <span class='hs-varid'>genes</span><span class='hs-layout'>)</span>
<a name="line-109"></a>                        <span class='hs-keyword'>in</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isJust</span> <span class='hs-varop'>`all`</span> <span class='hs-varid'>dists</span>
<a name="line-110"></a>                             <span class='hs-keyword'>then</span> <span class='hs-comment'>-- is a valid route</span>
<a name="line-111"></a>                                  <span class='hs-conid'>CompleteRoute</span> <span class='hs-varop'>.</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fromJust</span> <span class='hs-varid'>dists</span>
<a name="line-112"></a>                             <span class='hs-keyword'>else</span> <span class='hs-comment'>-- is incomplete</span>
<a name="line-113"></a>                                  <span class='hs-keyword'>let</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fromIntegral</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varop'>$</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>isJust</span> <span class='hs-varid'>dists</span><span class='hs-layout'>)</span>
<a name="line-114"></a>                                        <span class='hs-varop'>/</span> <span class='hs-varid'>fromIntegral</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>dists</span><span class='hs-layout'>)</span>
<a name="line-115"></a>                                      <span class='hs-varid'>poi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<a name="line-116"></a>                                      <span class='hs-varid'>len</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
<a name="line-117"></a>                                  <span class='hs-keyword'>in</span> <span class='hs-conid'>PartialRoute</span> <span class='hs-varid'>v</span> <span class='hs-varid'>poi</span> <span class='hs-varid'>len</span>
<a name="line-118"></a>
</pre>\end{code}



\item Generación de cromosomas aleatorios.

\begin{figure}[h]
    \centering
    \input{MapExampleRaw.tikz}
    \caption{Un exemplo de mapa, inicio: 0--2, meta: 9--3.}
    \label{fig:rawMapExample}
\end{figure}

\begin{figure}[h]
    \centering
    \input{MapExampleChromosomes.tikz}
    \caption{Se presentan algunos cromosomas en el mapa.
             Los cromosomas {\color{orange} •} {\color{blue} •} {\color{green} •} están compuestas
               de pares de genes, conectados por aristas;
             mientras que los cromosomas {\color{red} •} {\color{violet} •} están compuestos
               de cadenas de genes, conectados por aristas, de longitud 3.
            \textit{\small (Son de diferente grosor para que se ven mejor
                            las conecciones que existen en varios cromosomas)}
            }
    \label{fig:chromosomesMapExample}
\end{figure}


\noindent Para mejorar las poblaciones iniciales, las cromosomas se componen de
secuencias de genes, que son sub-rutas validas de tamaños diferentes.

En la figura \ref{fig:rawMapExample} se presenta un ejemplo de un mapa y
en la figura \ref{fig:chromosomesMapExample} se presenta un exemplo de cromosomas generados.






{\Huge \color{red} TBD \dots}






<pre><a name="line-119"></a><span class='hs-varop'>&gt;</span>    <span class='hs-comment'>-- randomChromosome :: ga \rightarrow$ IO (Chromosome ga)</span>
<a name="line-120"></a><span class='hs-varop'>&gt;</span>    <span class='hs-varid'>randomChromosome</span> <span class='hs-layout'>(</span><span class='hs-conid'>GA</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
</pre>

\item ?

<pre><a name="line-121"></a><span class='hs-varop'>&gt;</span>    <span class='hs-comment'>-- crossover :: Chromosome ga \rightarrow$ Chromosome ga</span>
<a name="line-122"></a><span class='hs-varop'>&gt;</span>    <span class='hs-comment'>-- \qquad\qquad \rightarrow$ CrossoverChildren ga (Chromosome ga)</span>
</pre>
\item ?

<pre><a name="line-123"></a><span class='hs-varop'>&gt;</span>    <span class='hs-comment'>-- mutate :: Chromosome ga \rightarrow$ Chromosome ga</span>
</pre>
\item ?

<pre><a name="line-124"></a><span class='hs-varop'>&gt;</span>    <span class='hs-comment'>-- stopCriteria :: [Fitness ga] \rightarrow$ Bool</span>
</pre>
\item ?

<pre><a name="line-125"></a><span class='hs-varop'>&gt;</span>    <span class='hs-comment'>-- newGA :: InputData ga \rightarrow$ ga</span>
</pre>

\end{enumerate}



\newpage

{\Huge \color{red} Esto es un reporte preliminar }

\begin{note}
  La intención es utilizar \emph{crossover} para:
  \begin{enumerate*}[1)]
    \item remplazar los ''hoyos'' en las rutas;
    \item extender rutas existientes.
  \end{enumerate*}
  La preferencia debe ser dada a las rutas que contienen un de los puntos de interes (inicio, meta).

  La mutación debe extender/remplacar un gen al inicio/meta si $\exists$ una ruta directa.

  \medskip
  \noindent {\Large \color{red} !} El concepto de \emph{''valides''} va ser cambiado.
\end{note}





\end{document}
</body>
</html>
