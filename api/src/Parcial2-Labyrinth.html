<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>src/Parcial2/Labyrinth.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
\documentclass{article}

%include polycode.fmt


\usepackage[utf8]{inputenc}
\usepackage[spanish, mexico]{babel}
\usepackage{amsmath, hyperref, xcolor, tikz, mdframed}
\usepackage[shortlabels, inline]{enumitem}

% \usepackage{showframe}

\newenvironment{note}
    {\begin{mdframed}[leftmargin=1cm,
                 skipabove=1em,
                 skipbelow=1em,
                 rightline=false,
                 topline=false,
                 bottomline=false,
                 linewidth=2pt]
        \textbf{Nota}\\}
    {\end{mdframed}}


\newcommand{\crule}[2][1pt] {\begin{center}\rule{#2\textwidth}{#1}\end{center}}

\newcommand{\hssrc} [2]{\href{api/src/#1.html}{src/#2}}
\newcommand{\hstest}[2]{\href{api/tests/src/#1.html}{test/#2}}


\begin{document}

\begin{code}
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE UndecidableInstances, FlexibleInstances #-}</span>
<a name="line-2"></a>
<a name="line-3"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Parcial2</span><span class='hs-varop'>.</span><span class='hs-conid'>Labyrinth</span> <span class='hs-keyword'>where</span>
<a name="line-4"></a>
<a name="line-5"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Exception</span>
<a name="line-6"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Arrow</span> <span class='hs-layout'>(</span><span class='hs-varid'>first</span><span class='hs-layout'>,</span> <span class='hs-varid'>second</span><span class='hs-layout'>)</span>
<a name="line-7"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>Fix</span>
<a name="line-8"></a>
<a name="line-9"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Tuple</span> <span class='hs-layout'>(</span><span class='hs-varid'>swap</span><span class='hs-layout'>)</span>
<a name="line-10"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>isJust</span><span class='hs-layout'>,</span> <span class='hs-varid'>fromJust</span><span class='hs-layout'>)</span>
<a name="line-11"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-layout'>(</span><span class='hs-conid'>Set</span><span class='hs-layout'>,</span> <span class='hs-varid'>member</span><span class='hs-layout'>)</span>
<a name="line-12"></a>  <span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Set</span>
<a name="line-13"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Real</span> <span class='hs-layout'>(</span><span class='hs-varid'>infinity</span><span class='hs-layout'>)</span>
<a name="line-14"></a>
<a name="line-15"></a>
<a name="line-16"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>Parcial2</span><span class='hs-varop'>.</span><span class='hs-conid'>ReadLabyrinth</span>
<a name="line-17"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>GeneticAlgorithm</span>
<a name="line-18"></a>
<a name="line-19"></a>  <span class='hs-keyword'>import</span> <span class='hs-conid'>System</span><span class='hs-varop'>.</span><span class='hs-conid'>Random</span>
</pre>\end{code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introducción}


El mapa (laberinto), descrito en la tarea, se define como un grafo:
nodos --- un conjunto de puntos (con posiciones correspondientes);
aristas --- la existencia de rutas directas.

\begin{code}
<pre><a name="line-20"></a>  <span class='hs-keyword'>data</span> <span class='hs-conid'>Labyrinth</span> <span class='hs-varid'>point</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Labyrinth</span> <span class='hs-layout'>{</span>
<a name="line-21"></a>        <span class='hs-varid'>nodes</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Set</span> <span class='hs-varid'>point</span><span class='hs-layout'>,</span>
<a name="line-22"></a>        <span class='hs-varid'>edges</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Set</span> <span class='hs-layout'>(</span><span class='hs-varid'>point</span><span class='hs-layout'>,</span> <span class='hs-varid'>point</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-23"></a>        <span class='hs-varid'>initial</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>point</span><span class='hs-layout'>,</span>
<a name="line-24"></a>        <span class='hs-varid'>target</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varid'>point</span>
<a name="line-25"></a>      <span class='hs-layout'>}</span>
<a name="line-26"></a>
<a name="line-27"></a>  <span class='hs-varid'>edgeOf</span> <span class='hs-varid'>p</span> <span class='hs-varid'>es</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varop'>`member`</span> <span class='hs-varid'>es</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>p</span><span class='hs-layout'>,</span> <span class='hs-varid'>swap</span> <span class='hs-varid'>p</span><span class='hs-keyglyph'>]</span>
<a name="line-28"></a>
<a name="line-29"></a>  <span class='hs-varid'>mapPoints</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Labyrinth</span> <span class='hs-varid'>ns</span> <span class='hs-varid'>es</span> <span class='hs-varid'>i</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Labyrinth</span> <span class='hs-layout'>{</span>
<a name="line-30"></a>        <span class='hs-varid'>nodes</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set</span><span class='hs-varop'>.</span><span class='hs-varid'>map</span> <span class='hs-varid'>f</span> <span class='hs-varid'>ns</span><span class='hs-layout'>,</span>
<a name="line-31"></a>        <span class='hs-varid'>edges</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set</span><span class='hs-varop'>.</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>first</span> <span class='hs-varid'>f</span> <span class='hs-varop'>.</span> <span class='hs-varid'>second</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varid'>es</span><span class='hs-layout'>,</span>
<a name="line-32"></a>        <span class='hs-varid'>initial</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>i</span><span class='hs-layout'>,</span>
<a name="line-33"></a>        <span class='hs-varid'>target</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>t</span>
<a name="line-34"></a>    <span class='hs-layout'>}</span>
<a name="line-35"></a>
</pre>\end{code}


Se define la \emph{distancia directa} entre los nodos que están conectados por una arista.

\begin{code}
<pre><a name="line-36"></a>  <span class='hs-keyword'>data</span> <span class='hs-conid'>DirectDistance</span> <span class='hs-varid'>point</span> <span class='hs-varid'>dist</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DirectDistance</span> <span class='hs-layout'>{</span>
<a name="line-37"></a>       <span class='hs-varid'>labyrinthDist</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Labyrinth</span> <span class='hs-varid'>point</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>point</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>point</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-varid'>dist</span>
<a name="line-38"></a>      <span class='hs-layout'>}</span>
<a name="line-39"></a>
<a name="line-40"></a>  <span class='hs-varid'>mkDirectDistance</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DirectDistance</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>l</span> <span class='hs-varid'>v1</span> <span class='hs-varid'>v2</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-41"></a>    <span class='hs-keyword'>if</span> <span class='hs-layout'>(</span><span class='hs-varid'>v1</span><span class='hs-layout'>,</span><span class='hs-varid'>v2</span><span class='hs-layout'>)</span> <span class='hs-varop'>`edgeOf`</span> <span class='hs-varid'>edges</span> <span class='hs-varid'>l</span> <span class='hs-keyword'>then</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>v1</span> <span class='hs-varid'>v2</span><span class='hs-layout'>)</span> <span class='hs-keyword'>else</span> <span class='hs-conid'>Nothing</span>
</pre>\end{code}




\bigskip
\noindent
El algoritmo genético abstracto está definido en \hssrc{GeneticAlgorithm}{GeneticAlgorithm.hs}.
Su implementación se presentará a continuación.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementación}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Lectura de mapas}

Se utiliza un mapa 2D:

<pre><a name="line-42"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>newtype</span> <span class='hs-conid'>Point2D</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Point2D</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Ord</span><span class='hs-layout'>)</span>
<a name="line-43"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Show</span> <span class='hs-conid'>Point2D</span> <span class='hs-keyword'>where</span>
<a name="line-44"></a><span class='hs-varop'>&gt;</span>   <span class='hs-varid'>show</span> <span class='hs-layout'>(</span><span class='hs-conid'>Point2D</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>show</span> <span class='hs-varid'>x</span> <span class='hs-varop'>++</span> <span class='hs-str'>"-"</span> <span class='hs-varop'>++</span> <span class='hs-varid'>show</span> <span class='hs-varid'>y</span>
</pre>
<pre><a name="line-45"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>Labyrinth2D</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Labyrinth</span> <span class='hs-conid'>Point2D</span>
</pre>

La lectura del archivo del mapa se encuentra en
\hssrc{Parcial2-ReadLabyrinth}{Parcial2/ReadLabyrinth.hs}.
Aquí se presenta la construcción del grafo a partir del mapa leido.


\begin{code}
<pre><a name="line-46"></a>  <span class='hs-varid'>readLabyrinth2D</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FilePath</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>String</span><span class='hs-keyglyph'>]</span> <span class='hs-conid'>Labyrinth2D</span><span class='hs-layout'>)</span>
<a name="line-47"></a>
<a name="line-48"></a>  <span class='hs-varid'>readLabyrinth2D</span> <span class='hs-varid'>file</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>build</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>try</span> <span class='hs-layout'>(</span><span class='hs-varid'>readFile</span> <span class='hs-varid'>file</span><span class='hs-layout'>)</span>
<a name="line-49"></a>    <span class='hs-keyword'>where</span>
<a name="line-50"></a>        <span class='hs-varid'>build</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-varid'>err</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Left</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>displayException</span> <span class='hs-layout'>(</span><span class='hs-varid'>err</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SomeException</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-51"></a>        <span class='hs-varid'>build</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>parseLabyrinth</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>of</span>
<a name="line-52"></a>                                   <span class='hs-conid'>Left</span> <span class='hs-varid'>errS</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Left</span> <span class='hs-varid'>errS</span>
<a name="line-53"></a>                                   <span class='hs-conid'>Right</span> <span class='hs-varid'>l</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-varid'>build'</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>
<a name="line-54"></a>
<a name="line-55"></a>        <span class='hs-varid'>build'</span> <span class='hs-layout'>(</span><span class='hs-conid'>LabyrinthDescription</span> <span class='hs-varid'>n</span> <span class='hs-varid'>conn</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-layout'>,</span><span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varid'>coords</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-56"></a>          <span class='hs-keyword'>let</span> <span class='hs-varid'>get</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Point2D</span> <span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>coords</span> <span class='hs-varop'>!!</span><span class='hs-layout'>)</span>
<a name="line-57"></a>          <span class='hs-keyword'>in</span> <span class='hs-conid'>Labyrinth</span>
<a name="line-58"></a>                       <span class='hs-layout'>(</span><span class='hs-conid'>Set</span><span class='hs-varop'>.</span><span class='hs-varid'>fromList</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-conid'>Point2D</span> <span class='hs-varid'>coords</span><span class='hs-layout'>)</span>
<a name="line-59"></a>                       <span class='hs-layout'>(</span><span class='hs-conid'>Set</span><span class='hs-varop'>.</span><span class='hs-varid'>fromList</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>first</span> <span class='hs-varid'>get</span> <span class='hs-varop'>.</span> <span class='hs-varid'>second</span> <span class='hs-varid'>get</span><span class='hs-layout'>)</span> <span class='hs-varid'>coords</span><span class='hs-layout'>)</span>
<a name="line-60"></a>                       <span class='hs-layout'>(</span><span class='hs-varid'>get</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span>
<a name="line-61"></a>                       <span class='hs-layout'>(</span><span class='hs-varid'>get</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-62"></a>
</pre>\end{code}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Adoptación}



Se define el valor de \emph{aptitud de adoptación} como uno de los dos:
\begin{itemize}
  \item longitud de la ruta completa;
  \item grado de valides $\dfrac
    {\text{número de aristas existentes}}
    {\text{número de aristas total}}$.

    \textit{aristas existentes ---
    aristas que existen entre los pares de genes ajustados.}
\end{itemize}

<pre><a name="line-63"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Route</span> <span class='hs-layout'>(</span><span class='hs-varid'>dir</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OrdDir</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RouteLength</span> <span class='hs-conid'>Double</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>RouteValidess</span> <span class='hs-conid'>Double</span>
<a name="line-64"></a><span class='hs-varop'>&gt;</span>           <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Show</span><span class='hs-layout'>)</span>
</pre>
\noindent También tiene un parametro de tipo para establecer la dirección de busqueda,
lo que determina el orden deseado.
Se define la orden sobre la aptitud de tal manera que dependiendo en la dirección:
\begin{itemize}
  \item \emph{Min} --- $\forall x \in \textit{longitud}, y \in \textit{valides} \Rightarrow x < y$;

\begin{code}
<pre><a name="line-65"></a>  <span class='hs-keyword'>instance</span> <span class='hs-conid'>Ord</span> <span class='hs-layout'>(</span><span class='hs-conid'>Route</span> <span class='hs-conid'>Min</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-66"></a>    <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>RouteLength</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>   <span class='hs-layout'>(</span><span class='hs-conid'>RouteLength</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compare</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span>
<a name="line-67"></a>    <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>RouteValidess</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>RouteValidess</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compare</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span>
<a name="line-68"></a>    <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>RouteLength</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>   <span class='hs-layout'>(</span><span class='hs-conid'>RouteValidess</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LT</span>
<a name="line-69"></a>    <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>RouteValidess</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>RouteLength</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GT</span>
</pre>\end{code}

  \item \emph{Max} --- $\forall x \in \textit{longitud}, y \in \textit{valides} \Rightarrow x > y$.

\begin{code}
<pre><a name="line-70"></a>  <span class='hs-keyword'>instance</span> <span class='hs-conid'>Ord</span> <span class='hs-layout'>(</span><span class='hs-conid'>Route</span> <span class='hs-conid'>Max</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-71"></a>    <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>RouteLength</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>   <span class='hs-layout'>(</span><span class='hs-conid'>RouteLength</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compare</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span>
<a name="line-72"></a>    <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>RouteValidess</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>RouteValidess</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compare</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span>
<a name="line-73"></a>    <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>RouteLength</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>   <span class='hs-layout'>(</span><span class='hs-conid'>RouteValidess</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GT</span>
<a name="line-74"></a>    <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>RouteValidess</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>RouteLength</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LT</span>
</pre>\end{code}

\end{itemize}


Las pruebas del contenedor \emph{Route} se encuentran en \hstest{Parcial2-Route}{Parcial2/Route.hs}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Algoritmo genético}


<pre><a name="line-75"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>GA</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GA</span> <span class='hs-conid'>Labyrinth2D</span>
</pre>
Se usa adelante un alias de tuple \verb|(a,a)| para denotar el número de hijos de \emph{crossover}.

\begin{code}
<pre><a name="line-76"></a>  <span class='hs-keyword'>newtype</span> <span class='hs-conid'>Pair</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Pair</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-77"></a>  <span class='hs-varid'>unwrapPair</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>p</span>
<a name="line-78"></a>  <span class='hs-varid'>pair2List</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span><span class='hs-layout'>,</span><span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>f</span><span class='hs-layout'>,</span><span class='hs-varid'>s</span><span class='hs-keyglyph'>]</span>
</pre>\end{code}



\noindent
Se define la metrica sobre los puntos del grafo:
$$
  \mathrm{dist}(p_1, p_2) = \begin{cases}
       \mathit{Just}~ d_E(p_1, p_2)
    &  \mbox{si } \exists \text{ arista, connectando } p_1 \text{ y } p_2
    \\ \mathit{Nothing}
    &  \mbox{en otro caso}
  \end{cases}
\text {, donde}

d_E \text{ --- es la distancia euclidiana entre dos puntos.}
$$


<pre><a name="line-79"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>eDist'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkDirectDistance</span> <span class='hs-varop'>$</span>
<a name="line-80"></a><span class='hs-varop'>&gt;</span>         <span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>Point2D</span> <span class='hs-layout'>(</span><span class='hs-varid'>x1</span><span class='hs-layout'>,</span><span class='hs-varid'>x2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Point2D</span> <span class='hs-layout'>(</span><span class='hs-varid'>y1</span><span class='hs-layout'>,</span><span class='hs-varid'>y2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-81"></a><span class='hs-varop'>&gt;</span>               <span class='hs-varid'>sqrt</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fromIntegral</span> <span class='hs-varop'>$</span>
<a name="line-82"></a><span class='hs-varop'>&gt;</span>               <span class='hs-varid'>abs</span><span class='hs-layout'>(</span><span class='hs-varid'>x1</span><span class='hs-comment'>-</span><span class='hs-varid'>x2</span><span class='hs-layout'>)</span><span class='hs-varop'>^</span><span class='hs-num'>2</span> <span class='hs-varop'>+</span> <span class='hs-varid'>abs</span><span class='hs-layout'>(</span><span class='hs-varid'>y1</span><span class='hs-comment'>-</span><span class='hs-varid'>y2</span><span class='hs-layout'>)</span><span class='hs-varop'>^</span><span class='hs-num'>2</span>
<a name="line-83"></a><span class='hs-varop'>&gt;</span> <span class='hs-definition'>eDist</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>labyrinthDist</span> <span class='hs-varid'>eDist'</span>
</pre>


\crule{1}
\medskip
\noindent
Se define la instancia de la clase \emph{GeneticAlgorithm} para \emph{GA}
empezando con los tipos y siguiendo con los métodos.

<pre><a name="line-84"></a><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>GeneticAlgorithm</span> <span class='hs-conid'>GA</span> <span class='hs-keyword'>where</span>
</pre>
\begin{enumerate}[(1)]

\item Un \emph{gen} se define como \underline{nodo del laberinto}
      y un \emph{cromosoma} como una \underline{lista de genes}.

<pre><a name="line-85"></a><span class='hs-varop'>&gt;</span>    <span class='hs-keyword'>type</span> <span class='hs-conid'>Gene</span> <span class='hs-conid'>GA</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Point2D</span>
<a name="line-86"></a><span class='hs-varop'>&gt;</span>    <span class='hs-keyword'>type</span> <span class='hs-conid'>Chromosome</span> <span class='hs-conid'>GA</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Point2D</span><span class='hs-keyglyph'>]</span>
<a name="line-87"></a><span class='hs-varop'>&gt;</span>    <span class='hs-comment'>-- listGenes :: Chromosome ga \rightarrow$ [Gene ga]</span>
<a name="line-88"></a><span class='hs-varop'>&gt;</span>    <span class='hs-varid'>listGenes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id</span>
</pre>
\item Los valores de aptitud ya fueron descritos previamente.

<pre><a name="line-89"></a><span class='hs-varop'>&gt;</span>    <span class='hs-keyword'>type</span> <span class='hs-conid'>Fitness</span> <span class='hs-conid'>GA</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Route</span> <span class='hs-conid'>Min</span>
</pre>

\item Para denotar que la operación de \emph{crossover} preserva el tamaño de población,
su resultado se marca como un par de hijos.

<pre><a name="line-90"></a><span class='hs-varop'>&gt;</span>    <span class='hs-keyword'>type</span> <span class='hs-conid'>CrossoverChildren</span> <span class='hs-conid'>GA</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Pair</span>
</pre>
\item La información de entrada para generación de la población --- el laberinto.

<pre><a name="line-91"></a><span class='hs-varop'>&gt;</span>    <span class='hs-keyword'>type</span> <span class='hs-conid'>InputData</span> <span class='hs-conid'>GA</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Labyrinth2D</span>
</pre>
\item El resultado es el \underline{mejor cromosoma} obtenido.

<pre><a name="line-92"></a><span class='hs-varop'>&gt;</span>    <span class='hs-keyword'>type</span> <span class='hs-conid'>ResultData</span> <span class='hs-conid'>GA</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Chromosome</span> <span class='hs-conid'>GA</span>
</pre>


\item La \textbf{aptitud de adoptación} se define como:

$$
f(c) &= \begin{cases}
  \mathit{Length} ~ \mathrm{length}
    & \mbox{si } \begin{tabular}{l}
             \forall i = \overline{[1,\mathrm{len}-1]} \Rightarrow \\
             \qquad \exists \text{ arista, connectando } c_{i-1} \text{ y } c_i \\
             \land ~\mathrm{initial} \in \{c\}\\
             \land ~\mathrm{target} \in \{c\}
      \end{tabular}
  \\
  \mathit{Validess} ~\mathrm{validess}
    & \mbox{en otro caso}
  \end{cases}
$$

\qquad\qquad  donde
\begin{align*}
\mathrm{length} &= \sum\limits_{i = 1}^{\mathrm{len}-1} \mathrm{dist}(c_{i-1}, c_i)
\\
\mathrm{validess} &= \text{grado de valides (se describe antes)}
\end{align*}


<pre><a name="line-93"></a><span class='hs-varop'>&gt;</span>    <span class='hs-comment'>-- fitness :: ga \rightarrow$ Chromosome ga \rightarrow$ Fitness ga</span>
<a name="line-94"></a><span class='hs-varop'>&gt;</span>    <span class='hs-varid'>fitness</span> <span class='hs-layout'>(</span><span class='hs-conid'>GA</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-varid'>genes</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span>
<a name="line-95"></a><span class='hs-varop'>&gt;</span>                               <span class='hs-varid'>lPairs</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span><span class='hs-conop'>:</span><span class='hs-varid'>s</span><span class='hs-conop'>:</span><span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span><span class='hs-layout'>,</span><span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>lPairs</span> <span class='hs-layout'>(</span><span class='hs-varid'>s</span><span class='hs-conop'>:</span><span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-96"></a><span class='hs-varop'>&gt;</span>                               <span class='hs-varid'>lPairs</span> <span class='hs-keyword'>_</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-97"></a><span class='hs-varop'>&gt;</span>                               <span class='hs-varid'>dists</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>uncurry</span> <span class='hs-varop'>$</span> <span class='hs-varid'>eDist</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>lPairs</span> <span class='hs-varid'>genes</span><span class='hs-layout'>)</span>
<a name="line-98"></a><span class='hs-varop'>&gt;</span>                           <span class='hs-keyword'>in</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isJust</span> <span class='hs-varop'>`all`</span> <span class='hs-varid'>dists</span>
<a name="line-99"></a><span class='hs-varop'>&gt;</span>                                <span class='hs-keyword'>then</span> <span class='hs-comment'>-- is a valid route</span>
<a name="line-100"></a><span class='hs-varop'>&gt;</span>                                     <span class='hs-conid'>RouteLength</span> <span class='hs-varop'>.</span> <span class='hs-varid'>sum</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fromJust</span> <span class='hs-varid'>dists</span>
<a name="line-101"></a><span class='hs-varop'>&gt;</span>                                <span class='hs-keyword'>else</span> <span class='hs-comment'>-- is incomplete</span>
<a name="line-102"></a><span class='hs-varop'>&gt;</span>                                     <span class='hs-conid'>RouteValidess</span> <span class='hs-varop'>$</span>
<a name="line-103"></a><span class='hs-varop'>&gt;</span>                                       <span class='hs-varid'>fromIntegral</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varop'>$</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>isJust</span> <span class='hs-varid'>dists</span><span class='hs-layout'>)</span>
<a name="line-104"></a><span class='hs-varop'>&gt;</span>                                       <span class='hs-varop'>/</span> <span class='hs-varid'>fromIntegral</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>dists</span><span class='hs-layout'>)</span>
</pre>



\item Generación de cromosomas aleatorios.

\begin{figure}[h]
    \centering
    \input{MapExampleRaw.tikz}
    \caption{Un exemplo de mapa, inicio: 0--2, meta: 9--3.}
    \label{fig:rawMapExample}
\end{figure}

\begin{figure}[h]
    \centering
    \input{MapExampleChromosomes.tikz}
    \caption{Se presentan algunos cromosomas en el mapa.
             Los cromosomas {\color{orange} •} {\color{blue} •} {\color{green} •} están compuestas
               de pares de genes, conectados por aristas;
             mientras que los cromosomas {\color{red} •} {\color{violet} •} están compuestos
               de cadenas de genes, conectados por aristas, de longitud 3.
            \textit{\small (Son de diferente grosor para que se ven mejor
                            las conecciones que existen en varios cromosomas)}
            }
    \label{fig:chromosomesMapExample}
\end{figure}


\noindent Para mejorar las poblaciones iniciales, las cromosomas se componen de
secuencias de genes, que son sub-rutas validas de tamaños diferentes.

En la figura \ref{fig:rawMapExample} se presenta un ejemplo de un mapa y
en la figura \ref{fig:chromosomesMapExample} se presenta un exemplo de cromosomas generados.






{\Huge \color{red} TBD \dots}






<pre><a name="line-105"></a><span class='hs-varop'>&gt;</span>    <span class='hs-comment'>-- randomChromosome :: ga \rightarrow$ IO (Chromosome ga)</span>
<a name="line-106"></a><span class='hs-varop'>&gt;</span>    <span class='hs-varid'>randomChromosome</span> <span class='hs-layout'>(</span><span class='hs-conid'>GA</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>undefined</span>
</pre>

\item ?

<pre><a name="line-107"></a><span class='hs-varop'>&gt;</span>    <span class='hs-comment'>-- crossover :: Chromosome ga \rightarrow$ Chromosome ga</span>
<a name="line-108"></a><span class='hs-varop'>&gt;</span>    <span class='hs-comment'>-- \qquad\qquad \rightarrow$ CrossoverChildren ga (Chromosome ga)</span>
</pre>
\item ?

<pre><a name="line-109"></a><span class='hs-varop'>&gt;</span>    <span class='hs-comment'>-- mutate :: Chromosome ga \rightarrow$ Chromosome ga</span>
</pre>
\item ?

<pre><a name="line-110"></a><span class='hs-varop'>&gt;</span>    <span class='hs-comment'>-- stopCriteria :: [Fitness ga] \rightarrow$ Bool</span>
</pre>
\item ?

<pre><a name="line-111"></a><span class='hs-varop'>&gt;</span>    <span class='hs-comment'>-- newGA :: InputData ga \rightarrow$ ga</span>
</pre>

\end{enumerate}



\newpage

{\Huge \color{red} Esto es un reporte preliminar }

\begin{note}
  La intención es utilizar \emph{crossover} para:
  \begin{enumerate*}[1)]
    \item remplazar los ''hoyos'' en las rutas;
    \item extender rutas existientes.
  \end{enumerate*}
  La preferencia debe ser dada a las rutas que contienen un de los puntos de interes (inicio, meta).

  La mutación debe extender/remplacar un gen al inicio/meta si $\exists$ una ruta directa.

  \medskip
  \noindent {\Large \color{red} !} El concepto de \emph{''valides''} va ser cambiado.
\end{note}





\end{document}
</body>
</html>
